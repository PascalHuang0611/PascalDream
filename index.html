<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>自動戰鬥遊戲</title>
    <style>
        /* --- 整體頁面樣式 --- */
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background-color: #1a1a1a;
            color: #e0e0e0;
            display: flex;
            justify-content: flex-start; /* 改為左對齊以修復滾軸問題 */
            align-items: flex-start; /* 頂部對齊 */
            min-height: 100vh;
            margin: 0;
            padding: 20px;
            box-sizing: border-box;
            overflow-x: auto; /* 當內容超出螢幕寬度時，顯示水平滾軸 */
        }

        /* --- 主應用程式包裹容器 --- */
        #app-wrapper {
            display: flex;
            flex-direction: row; /* 始終保持水平排列 */
            align-items: flex-start;
            gap: 20px;
        }

        /* --- 修煉面板 --- */
        #cultivation-panel {
            width: 300px;
            height: 700px;
            background-color: #2a2a2a;
            border: 2px solid #444;
            border-radius: 15px;
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 15px;
            box-sizing: border-box;
            gap: 10px; /* 稍微調整間距 */
            flex-shrink: 0;
        }
        #cultivation-panel h2 {
            margin: 0;
            color: #00bcd4;
            text-align: center;
        }

        /* 天氣資訊 */
        #weather-info {
            width: 100%;
            text-align: center;
            padding: 10px;
            background-color: rgba(0, 0, 0, 0.2);
            border-radius: 8px;
            font-size: 14px;
        }
        #weather-info p {
            margin: 4px 0;
        }
        #weather-location {
            font-weight: bold;
            font-size: 16px;
        }

        .meditation-visual {
            flex-grow: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            width: 100%;
        }
        
        .meditation-container {
            position: relative;
            width: 200px;
            height: 200px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .meditating-person-img {
            width: 150px;
            height: 150px;
            object-fit: contain; /* 避免圖片被拉伸 */
        }
        
        /* --- 寵物樣式 --- */
        .pet-container {
            position: absolute;
            bottom: 5px;
            right: 35px;
            display: flex;
            flex-direction: column;
            align-items: center;
            animation: float-pet 3s ease-in-out infinite;
        }
        .pet-img {
            width: 40px;
            height: 40px;
            object-fit: contain;
            cursor: pointer; /* 新增手指游標 */
        }
        .pet-name-container {
            display: flex;
            align-items: center;
            gap: 5px;
            color: #ffd700;
            font-size: 12px; /* 將字體縮小 */
            margin-top: 2px;
            text-shadow: 1px 1px 2px #000;
        }
        #edit-pet-name {
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        #edit-pet-name svg {
            stroke: #aaa;
            transition: stroke 0.2s ease;
        }
        #edit-pet-name:hover svg {
            stroke: #fff;
        }

        @keyframes float-pet {
            0% { transform: translateY(0px); }
            50% { transform: translateY(-8px); }
            100% { transform: translateY(0px); }
        }


        .revolving-orb {
            position: absolute;
            top: 50%; /* 將動畫中心點設在容器中央 */
            left: 50%;
            width: 20px;
            height: 20px;
            background-color: #00e5ff; /* 預設顏色，會被 JS 覆蓋 */
            border-radius: 50%;
            box-shadow: 0 0 10px #00e5ff, 0 0 20px #00e5ff, 0 0 30px #fff; /* 預設光暈，會被 JS 覆蓋 */
            animation: revolve 10s linear infinite;
        }

        @keyframes revolve {
            from {
                transform: translate(-50%, -50%) rotate(0deg) translateX(100px) rotate(0deg);
            }
            to {
                transform: translate(-50%, -50%) rotate(360deg) translateX(100px) rotate(-360deg);
            }
        }

        .cultivation-stats {
            width: 100%;
            text-align: center;
            font-size: 14px; 
        }
         .cultivation-stats p {
            margin: 5px 0;
        }
        #cultivation-level-name {
            font-size: 20px;
            font-weight: bold;
            color: #FFD700; 
            transition: color 0.5s ease, text-shadow 0.5s ease;
        }

        /* 後期境界光暈效果 */
        #cultivation-level-name.late-stage-glow {
            text-shadow: 0 0 5px #fff, 0 0 8px currentColor;
        }

        /* 大圓滿境界脈動光暈 */
        #cultivation-level-name.perfection-glow {
            animation: perfection-pulse 2s infinite;
        }

        @keyframes perfection-pulse {
            0% { text-shadow: 0 0 5px #fff, 0 0 10px currentColor; }
            50% { text-shadow: 0 0 15px #fff, 0 0 25px currentColor; }
            100% { text-shadow: 0 0 5px #fff, 0 0 10px currentColor; }
        }
        
        
        /* --- 遊戲主容器 --- */
        #game-container {
            width: 850px; /* 固定寬度以維持版面 */
            height: 700px;
            background-color: #2a2a2a;
            border: 2px solid #444;
            border-radius: 15px;
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
            display: flex;
            flex-direction: column;
            padding: 15px;
            box-sizing: border-box;
            gap: 15px;
            flex-shrink: 0; /* 防止容器被壓縮 */
        }

        /* 戰鬥畫面容器 */
        #combat-screen {
            flex-grow: 1;
            position: relative;
            min-height: 250px;
            background-color: #333; 
            border: 1px solid #4f4f4f; 
            border-radius: 10px;      
        }

        /* --- 測試控制項 --- */
        #test-controls {
            padding: 15px;
            background-color: #2a2a2a;
            border: 2px solid #444;
            border-radius: 15px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            width: 200px;
            flex-shrink: 0; /* 防止此容器也被壓縮 */
        }
        #test-controls label {
            font-weight: bold;
            color: #ffa500;
        }
        #test-controls select {
            padding: 8px;
            background-color: #3c3c3c;
            color: #e0e0e0;
            border: 1px solid #555;
            border-radius: 5px;
            font-size: 16px;
            cursor: pointer;
        }


        /* 畫面震動攻擊特效 */
        .screen-shake {
            animation: shake 0.3s cubic-bezier(.36,.07,.19,.97) both;
        }

        @keyframes shake {
          10%, 90% { transform: translate3d(-1px, 0, 0); }
          20%, 80% { transform: translate3d(2px, 0, 0); }
          30%, 50%, 70% { transform: translate3d(-4px, 0, 0); }
          40%, 60% { transform: translate3d(4px, 0, 0); }
        }

        /* --- 角色卡片通用樣式 --- */
        .character-card {
            width: 200px;
            padding: 15px;
            background-color: #3c3c3c;
            border: 1px solid #555;
            border-radius: 10px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
            position: absolute; 
            transition: transform 0.2s ease;
        }

        .character-card h2 {
            margin-top: 0;
            color: #ffa500;
        }

        .character-card.attacking {
            transform: scale(1.1);
        }

        #player { bottom: 20px; left: 20px; }
        #monster { top: 20px; right: 20px; }

        /* --- 血條/行動條樣式 --- */
        .bar-container {
            width: 100%;
            height: 18px;
            background-color: #1e1e1e;
            border-radius: 9px;
            overflow: hidden;
            border: 1px solid #555;
            margin-top: 5px;
        }
        .bar { height: 100%; border-radius: 8px; transition: width 0.1s linear; }
        #player-health-bar { background-color: #4caf50; }
        #monster-health-bar { background-color: #f44336; }
        #player-action-bar { background-color: #00bcd4; }
        #monster-action-bar { background-color: #ff9800; }
        #exp-progress-bar { background-color: #FFD700; }
        .hp-text { font-size: 14px; text-align: center; margin-top: 5px; font-weight: bold; }

        /* --- 戰鬥日誌與控制 --- */
        #controls { display: flex; flex-direction: column; align-items: center; gap: 15px; flex-shrink: 0; }
        #combat-log { width: 100%; height: 140px; background-color: rgba(0,0,0,0.3); border: 1px solid #555; padding: 10px; overflow-y: auto; border-radius: 8px; font-family: monospace; font-size: 14px; box-sizing: border-box; flex-shrink: 0; }
        #combat-log p { margin: 0 0 5px 0; padding: 0; color: #ddd; }

        /* --- 按鈕樣式 --- */
        button { padding: 12px 25px; font-size: 18px; font-weight: bold; color: white; background: linear-gradient(145deg, #ff8c00, #ffa500); border: none; border-radius: 8px; cursor: pointer; box-shadow: 0 4px 6px rgba(0,0,0,0.4); transition: all 0.2s ease; }
        button:hover { transform: translateY(-2px); box-shadow: 0 6px 8px rgba(0,0,0,0.5); filter: brightness(1.1); }
        button:active { transform: translateY(1px); box-shadow: 0 2px 3px rgba(0,0,0,0.4); }
        button:disabled { background: #555; cursor: not-allowed; transform: none; box-shadow: none; }
        #breakthrough-button.ready {
            background: linear-gradient(145deg, #ff416c, #ff4b2b);
            animation: pulse 1.5s infinite;
        }
        @keyframes pulse {
            0% { box-shadow: 0 0 0 0 rgba(255, 65, 108, 0.7); }
            70% { box-shadow: 0 0 0 10px rgba(255, 65, 108, 0); }
            100% { box-shadow: 0 0 0 0 rgba(255, 65, 108, 0); }
        }
        
        /* --- 特效樣式 --- */
        .damage-indicator {
            position: absolute;
            font-size: 26px;
            font-weight: bold;
            color: #ffffff; /* 改為白色字體 */
            /* 新增紅色外框與黑色陰影 */
            text-shadow: 
                -1px -1px 0 #c00, 1px -1px 0 #c00, 
                -1px 1px 0 #c00, 1px 1px 0 #c00, 
                2px 2px 4px rgba(0,0,0,0.8);
            animation: floatUp 1s ease-out forwards;
            pointer-events: none;
            z-index: 10;
        }
        @keyframes floatUp {
            from { opacity: 1; transform: translateY(0); }
            to { opacity: 0; transform: translateY(-60px); }
        }

        .exp-indicator {
            position: absolute;
            font-size: 22px;
            font-weight: bold;
            color: #FFD700; /* Gold */
            text-shadow: 1px 1px 2px #000;
            animation: floatUp 1s ease-out forwards;
            pointer-events: none;
            z-index: 10;
        }

        .slash-effect {
            position: absolute;
            width: 100px;
            height: 120px;
            pointer-events: none;
            z-index: 10;
            animation: slash-anim 0.3s ease-out forwards;
        }
        .slash-effect::after {
            content: '';
            position: absolute;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, transparent 45%, white 48%, white 52%, transparent 55%);
            transform: rotate(10deg);
        }
        @keyframes slash-anim {
            0% { transform: scale(0) rotate(0); opacity: 0; }
            50% { transform: scale(1.2) rotate(10deg); opacity: 1; }
            100% { transform: scale(1.2) rotate(20deg); opacity: 0; }
        }
        
        .impact-effect {
            position: absolute;
            width: 90px;
            height: 90px;
            border-radius: 50%;
            pointer-events: none;
            z-index: 10;
            background: radial-gradient(circle, rgba(255, 255, 255, 0.9) 0%, rgba(255, 215, 0, 0.8) 30%, rgba(255, 165, 0, 0) 65%);
            animation: impact-anim 0.35s ease-out forwards;
        }
        @keyframes impact-anim {
             0% { transform: scale(0.5); opacity: 1; }
             80% { transform: scale(1.6); opacity: 0.5; }
             100% { transform: scale(1.9); opacity: 0; }
        }

        /* 渡劫成功特效 */
        .ascension-effect {
            position: absolute;
            width: 300px;
            height: 300px;
            border-radius: 50%;
            background: radial-gradient(circle, rgba(255, 255, 255, 0.9) 0%, rgba(255, 223, 0, 0.8) 40%, rgba(255, 215, 0, 0) 70%);
            pointer-events: none;
            z-index: 20;
            animation: ascend-anim 1.2s ease-out forwards;
        }
        @keyframes ascend-anim {
            0% { transform: scale(0); opacity: 1; }
            80% { transform: scale(1.5); opacity: 0.5; }
            100% { transform: scale(1.8); opacity: 0; }
        }

        /* 渡劫失敗特效 */
        .lightning-effect {
            position: absolute;
            top: -100px;
            left: 50%;
            transform: translateX(-50%);
            width: 30px;
            height: 250px;
            background: linear-gradient(to bottom, rgba(255,255,255,0) 0%, #fff 50%, rgba(255,255,255,0) 100%);
            pointer-events: none;
            z-index: 20;
            clip-path: polygon(100% 0, 100% 0, 100% 12%, 42% 12%, 100% 31%, 100% 38%, 31% 38%, 100% 59%, 100% 67%, 32% 67%, 100% 91%, 100% 100%, 0 100%, 0 100%, 0 88%, 59% 88%, 0 68%, 0 61%, 69% 61%, 0 40%, 0 32%, 71% 32%, 0 10%, 0 0);
            animation: lightning-flash 0.5s ease-out forwards;
        }
        @keyframes lightning-flash {
            0%, 100% { opacity: 0; }
            10%, 30%, 50%, 70% { opacity: 1; }
            20%, 40%, 60%, 80% { opacity: 0; }
        }

        .screen-flash-red {
            animation: screen-flash-anim 0.5s ease-out;
        }
        @keyframes screen-flash-anim {
            0% { background-color: rgba(255, 0, 0, 0); }
            50% { background-color: rgba(150, 0, 0, 0.5); }
            100% { background-color: rgba(255, 0, 0, 0); }
        }
        
        /* --- 自訂提示訊息樣式 --- */
        .alert-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        .alert-box {
            background: #2a2a2a;
            padding: 25px 30px;
            border-radius: 10px;
            border: 1px solid #444;
            text-align: center;
            box-shadow: 0 5px 15px rgba(0,0,0,0.5);
        }

        .alert-box p {
            margin: 0 0 20px 0;
            font-size: 18px;
            color: #e0e0e0;
        }

        .alert-box button {
            padding: 8px 20px;
            font-size: 16px;
        }

    </style>
</head>
<body>
    <div id="app-wrapper">
        <!-- 修煉面板 -->
        <div id="cultivation-panel">
            <h2>修煉</h2>
            <div id="weather-info">
                <p><span id="weather-location">讀取天氣中...</span></p>
                <p><span id="weather-condition">--</span> | 溫度: <span id="weather-temp">--</span>°C | 濕度: <span id="weather-humidity">--</span>%</p>
            </div>
            <div class="meditation-visual">
                <div class="meditation-container">
                    <img src="./player_image.png" alt="修煉中的小人" class="meditating-person-img" onerror="this.style.display='none'">
                    <div class="pet-container">
                        <img src="./pet_image.png" alt="寵物" class="pet-img" onerror="this.style.display='none'">
                        <div class="pet-name-container">
                            <span id="pet-name">于庭</span>
                            <span id="edit-pet-name">
                                <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M17 3a2.828 2.828 0 1 1 4 4L7.5 20.5 2 22l1.5-5.5L17 3z"></path></svg>
                            </span>
                        </div>
                    </div>
                    <!-- 光球將由 JavaScript 動態生成 -->
                </div>
            </div>
            <div class="cultivation-stats">
                <p id="cultivation-level-name">煉氣期 前期 (第1層)</p>
                <div class="bar-container"><div id="exp-progress-bar" class="bar"></div></div>
                <p>經驗: <span id="player-exp">0</span> / <span id="exp-required">100</span></p>
                <p>修煉速度: <span id="exp-rate">1.00</span> 點/秒</p>
                <p>渡劫成功率: <span id="tribulation-rate">--</span>%</p>
                <button id="breakthrough-button" disabled>修練中...</button>
            </div>
        </div>

        <div id="game-container">
            <!-- 戰鬥畫面 -->
            <div id="combat-screen">
                <!-- 怪物顯示區 -->
                <div id="monster" class="character-card">
                    <h2 id="monster-name"></h2>
                    <p>生命:</p>
                    <div class="bar-container"><div id="monster-health-bar" class="bar"></div></div>
                    <p class="hp-text" id="monster-hp-text"></p>
                    <p>行動條:</p>
                    <div class="bar-container"><div id="monster-action-bar" class="bar"></div></div>
                    <p>攻擊: <span id="monster-atk"></span> | 防禦: <span id="monster-def"></span> | 速度: <span id="monster-spd"></span></p>
                </div>

                <!-- 玩家顯示區 -->
                <div id="player" class="character-card">
                    <h2>玩家</h2>
                    <p>生命:</p>
                    <div class="bar-container"><div id="player-health-bar" class="bar"></div></div>
                    <p class="hp-text" id="player-hp-text"></p>
                    <p>行動條:</p>
                    <div class="bar-container"><div id="player-action-bar" class="bar"></div></div>
                    <p>攻擊: <span id="player-atk"></span> | 防禦: <span id="player-def"></span> | 速度: <span id="player-spd"></span></p>
                </div>
            </div>

            <!-- 戰鬥日誌 -->
            <div id="combat-log"></div>

            <!-- 控制按鈕 -->
            <div id="controls">
                <button id="start-pause-button">開始戰鬥</button>
                <button id="restart-button" style="display: none;">重新開始</button>
            </div>
        </div>

        <!-- 測試用控制項 -->
        <div id="test-controls">
            <label for="monster-select">選擇測試怪物:</label>
            <select id="monster-select"></select>
        </div>
    </div>

    <!-- 自訂提示訊息 HTML -->
    <div id="custom-alert-overlay" class="alert-overlay" style="display: none;">
        <div id="custom-alert-box" class="alert-box">
            <p id="custom-alert-message"></p>
            <button id="custom-alert-close">臣妾知道了</button>
        </div>
    </div>


    <!-- 載入設定檔 (加入版本號 ?v=1.2 來避免快取問題) -->
    <script src="monsters.js?v=1.0"></script>
    <script src="cultivation_levels.js?v=1.2"></script>


    <script>
        // --- 1. 初始角色數值 ---
        const initialPlayerStats = { name: "玩家", maxHp: 100, hp: 100, atk: 20, def: 5, spd: 20 };
        const PET_NORMAL_IMAGE = './pet_image.png';
        const PET_CRY_IMAGE = './pet_image_cry.png'; // 寵物哭泣的圖片路徑
        
        let playerStats = { ...initialPlayerStats, actionProgress: 0 };
        let monsterStats = {}; // 初始化為空物件，將由 resetGame 填入

        // --- 遊戲狀態變數 ---
        let playerExperience = 0;
        let cultivationLevelIndex = 0;
        let isAwaitingTribulation = false;
        let currentTemperature = null;
        let currentHumidity = null;
        let monsterLevel = 1;
        let isGameRunning = false;
        let gameInterval = null;
        let petCryTimeout = null; // 用於控制寵物圖片恢復的計時器
        const ACTION_THRESHOLD = 1000;
        const TICK_RATE = 50;

        // --- 2. 獲取 HTML 元素 ---
        const weatherLocationEl = document.getElementById('weather-location');
        const weatherConditionEl = document.getElementById('weather-condition');
        const weatherTempEl = document.getElementById('weather-temp');
        const weatherHumidityEl = document.getElementById('weather-humidity');
        const cultivationLevelNameEl = document.getElementById('cultivation-level-name');
        const playerExpEl = document.getElementById('player-exp');
        const expRequiredEl = document.getElementById('exp-required');
        const expProgressBarEl = document.getElementById('exp-progress-bar');
        const expRateEl = document.getElementById('exp-rate');
        const tribulationRateEl = document.getElementById('tribulation-rate');
        const breakthroughButton = document.getElementById('breakthrough-button');
        const playerHpTextEl = document.getElementById('player-hp-text');
        const playerAtkEl = document.getElementById('player-atk');
        const playerDefEl = document.getElementById('player-def');
        const playerSpdEl = document.getElementById('player-spd');
        const playerHealthBarEl = document.getElementById('player-health-bar');
        const playerActionBarEl = document.getElementById('player-action-bar');
        const monsterNameEl = document.getElementById('monster-name');
        const monsterHpTextEl = document.getElementById('monster-hp-text');
        const monsterAtkEl = document.getElementById('monster-atk');
        const monsterDefEl = document.getElementById('monster-def');
        const monsterSpdEl = document.getElementById('monster-spd');
        const monsterHealthBarEl = document.getElementById('monster-health-bar');
        const monsterActionBarEl = document.getElementById('monster-action-bar');
        const startPauseButton = document.getElementById('start-pause-button');
        const restartButton = document.getElementById('restart-button');
        const combatLog = document.getElementById('combat-log');
        const playerCard = document.getElementById('player');
        const monsterCard = document.getElementById('monster');
        const combatScreenEl = document.getElementById('combat-screen');
        const meditationContainerEl = document.querySelector('.meditation-container');
        const monsterSelectEl = document.getElementById('monster-select');
        const petImgEl = document.querySelector('.pet-img'); // 獲取寵物圖片元素
        const editPetNameEl = document.getElementById('edit-pet-name');
        const customAlertOverlay = document.getElementById('custom-alert-overlay');
        const customAlertMessage = document.getElementById('custom-alert-message');
        const customAlertClose = document.getElementById('custom-alert-close');


        // --- 3. 遊戲核心功能 ---

        // --- 自訂提示訊息功能 ---
        function showCustomAlert(message) {
            customAlertMessage.textContent = message;
            customAlertOverlay.style.display = 'flex';
        }
        function hideCustomAlert() {
            customAlertOverlay.style.display = 'none';
        }

        function translateWeatherCode(code) {
            const weatherMap = {
                0: "晴天 ☀️", 1: "晴時多雲 🌤️", 2: "多雲 🌥️", 3: "陰天 ☁️",
                45: "霧 🌫️", 48: "霧 🌫️", 51: "毛毛雨 💧", 53: "毛毛雨 💧",
                55: "毛毛雨 💧", 61: "雨天 🌧️", 63: "大雨 🌧️", 65: "豪雨 🌧️",
                80: "陣雨 🌦️", 81: "陣雨 🌦️", 82: "強陣雨 🌦️", 95: "雷雨 ⛈️",
                96: "雷雨 ⛈️", 99: "雷雨 ⛈️",
            };
            return weatherMap[code] || "未知天氣";
        }

        function calculateExperienceGain() {
            if (currentTemperature === null || currentHumidity === null) return 1.0;
            const OPTIMAL_TEMP_MIN = 20, OPTIMAL_TEMP_MAX = 25;
            const BAD_TEMP_LOW = 10, BAD_TEMP_HIGH = 35;
            const OPTIMAL_HUMID_MIN = 40, OPTIMAL_HUMID_MAX = 60;
            const BAD_HUMID_LOW = 20, BAD_HUMID_HIGH = 80;
            function calculateBonus(value, min, max, badLow, badHigh) {
                if (value >= min && value <= max) return 1.0;
                if (value < min && value > badLow) return (value - badLow) / (min - badLow);
                if (value > max && value < badHigh) return 1.0 - ((value - max) / (badHigh - max));
                return 0.0;
            }
            const tempBonus = calculateBonus(currentTemperature, OPTIMAL_TEMP_MIN, OPTIMAL_TEMP_MAX, BAD_TEMP_LOW, BAD_TEMP_HIGH);
            const humidBonus = calculateBonus(currentHumidity, OPTIMAL_HUMID_MIN, OPTIMAL_HUMID_MAX, BAD_HUMID_LOW, BAD_HUMID_HIGH);
            return 1 + tempBonus + humidBonus;
        }

        async function fetchWeather() {
            if (navigator.geolocation) {
                navigator.geolocation.getCurrentPosition(async (position) => {
                    const lat = position.coords.latitude;
                    const lon = position.coords.longitude;
                    
                    // Step 1: Reverse Geocode to get location name
                    let locationName = '未知地區';
                    try {
                        const geoUrl = `https://nominatim.openstreetmap.org/reverse?format=json&lat=${lat}&lon=${lon}`;
                        const geoResponse = await fetch(geoUrl);
                        if (!geoResponse.ok) throw new Error('Reverse geocoding API error');
                        const geoData = await geoResponse.json();
                        locationName = geoData.address.city || geoData.address.town || geoData.address.suburb || '您的目前位置';
                    } catch (geoError) {
                        console.error("無法進行反向地理編碼:", geoError);
                    }

                    // Step 2: Fetch weather using coordinates
                    const weatherUrl = `https://api.open-meteo.com/v1/forecast?latitude=${lon}&longitude=${lon}&current=temperature_2m,relative_humidity_2m,weather_code`;
                    try {
                        const weatherResponse = await fetch(weatherUrl);
                        if (!weatherResponse.ok) throw new Error('天氣API回應錯誤');
                        const weatherData = await weatherResponse.json();
                        
                        currentTemperature = weatherData.current.temperature_2m;
                        currentHumidity = weatherData.current.relative_humidity_2m;
                        
                        weatherLocationEl.textContent = locationName;
                        weatherConditionEl.textContent = translateWeatherCode(weatherData.current.weather_code);
                        weatherTempEl.textContent = currentTemperature;
                        weatherHumidityEl.textContent = currentHumidity;
                        expRateEl.textContent = calculateExperienceGain().toFixed(2);

                    } catch (error) {
                        console.error("無法獲取天氣資訊:", error);
                        weatherLocationEl.textContent = "無法載入天氣";
                    }
                }, (error) => {
                    console.error("地理位置錯誤:", error);
                    weatherLocationEl.textContent = "無法獲取您的位置";
                });
            } else {
                weatherLocationEl.textContent = "瀏覽器不支援地理位置";
            }
        }

        function updateCultivationUI() {
            const currentLevelData = CULTIVATION_DATA[cultivationLevelIndex];
            const expRequired = currentLevelData.expRequired;

            cultivationLevelNameEl.textContent = currentLevelData.displayName;
            cultivationLevelNameEl.style.color = currentLevelData.color;
            
            cultivationLevelNameEl.classList.remove('late-stage-glow', 'perfection-glow');
            if (currentLevelData.stageName === "後期") {
                cultivationLevelNameEl.classList.add('late-stage-glow');
            } else if (currentLevelData.stageName === "大圓滿") {
                cultivationLevelNameEl.classList.add('perfection-glow');
            }

            playerExpEl.textContent = Math.round(playerExperience);
            expRequiredEl.textContent = isFinite(expRequired) ? expRequired : '---';
            
            const progress = isFinite(expRequired) ? (playerExperience / expRequired) * 100 : 100;
            expProgressBarEl.style.width = `${Math.min(100, progress)}%`;

            if (currentLevelData.isTribulationLevel) {
                 tribulationRateEl.textContent = (currentLevelData.tribulationSuccessRate * 100).toFixed(0);
            } else {
                 tribulationRateEl.textContent = '--';
            }

            if (isAwaitingTribulation) {
                breakthroughButton.disabled = false;
                breakthroughButton.textContent = "渡劫";
                breakthroughButton.classList.add('ready');
            } else {
                breakthroughButton.disabled = true;
                breakthroughButton.textContent = "修練中...";
                breakthroughButton.classList.remove('ready');
            }
        }

        function updateRevolvingOrbs() {
            const currentLevelData = CULTIVATION_DATA[cultivationLevelIndex];
            const realmIndex = currentLevelData.realmIndex;
            const numberOfOrbs = realmIndex + 1;
            const animationDuration = 10; 

            meditationContainerEl.querySelectorAll('.revolving-orb').forEach(orb => orb.remove());

            for (let i = 0; i < numberOfOrbs; i++) {
                const orb = document.createElement('div');
                orb.className = 'revolving-orb';

                const delay = -(animationDuration / numberOfOrbs) * i;
                orb.style.animationDelay = `${delay}s`;

                const orbColor = REALM_DEFINITIONS[i].color;

                orb.style.backgroundColor = orbColor;
                orb.style.boxShadow = `0 0 10px ${orbColor}, 0 0 20px ${orbColor}, 0 0 30px #fff`;

                meditationContainerEl.appendChild(orb);
            }
        }

        function levelUp() {
            const oldLevelData = CULTIVATION_DATA[cultivationLevelIndex];
            playerExperience -= oldLevelData.expRequired;
            cultivationLevelIndex++;
            const newLevelData = CULTIVATION_DATA[cultivationLevelIndex];
            logMessage(`恭喜！你成功晉升到了 ${newLevelData.displayName}！`, newLevelData.color);

            if (newLevelData.realmIndex !== oldLevelData.realmIndex) {
                updateRevolvingOrbs(); 
            }
        }

        function playTribulationAnimation(isSuccess) {
            const effect = document.createElement('div');
            if (isSuccess) {
                effect.className = 'ascension-effect';
                meditationContainerEl.appendChild(effect);
                setTimeout(() => effect.remove(), 1200);
            } else {
                effect.className = 'lightning-effect';
                const flashOverlay = document.createElement('div');
                flashOverlay.style.position = 'fixed';
                flashOverlay.style.top = '0';
                flashOverlay.style.left = '0';
                flashOverlay.style.width = '100vw';
                flashOverlay.style.height = '100vh';
                flashOverlay.style.zIndex = '999';
                flashOverlay.style.pointerEvents = 'none';
                flashOverlay.className = 'screen-flash-red';
                
                document.body.appendChild(flashOverlay);
                meditationContainerEl.appendChild(effect);

                setTimeout(() => effect.remove(), 500);
                setTimeout(() => flashOverlay.remove(), 500);
            }
        }

        function attemptBreakthrough() {
            if (!isAwaitingTribulation) return;

            const currentLevelData = CULTIVATION_DATA[cultivationLevelIndex];
            const successRate = currentLevelData.tribulationSuccessRate;
            
            if (Math.random() < successRate) {
                playTribulationAnimation(true);
                const nextLevelData = CULTIVATION_DATA[cultivationLevelIndex + 1];
                logMessage(`天雷淬體，渡劫成功！恭喜突破至 ${nextLevelData.displayName}！`, nextLevelData.color);
                levelUp();
                isAwaitingTribulation = false;
            } else {
                playTribulationAnimation(false);
                const penalty = currentLevelData.expRequired * 0.20;
                playerExperience -= penalty;
                if (playerExperience < 0) playerExperience = 0;
                logMessage(`渡劫失敗，真氣逆行，損失了 ${Math.round(penalty)} 點修為...`, '#dc3545');
                isAwaitingTribulation = false;
            }
            updateCultivationUI();
        }

        function checkLevelUp() {
            const currentLevelData = CULTIVATION_DATA[cultivationLevelIndex];
            if (!currentLevelData) return;
            
            const expRequired = currentLevelData.expRequired;

            if (isFinite(expRequired) && playerExperience >= expRequired) {
                if (currentLevelData.isTribulationLevel) {
                    playerExperience = expRequired;
                    isAwaitingTribulation = true;
                } else {
                    levelUp();
                }
            }
            updateCultivationUI();
        }

        function gainExperience() {
            if (isAwaitingTribulation) return;
            const currentLevelData = CULTIVATION_DATA[cultivationLevelIndex];
            if (!currentLevelData) return;
            
            const expAmount = calculateExperienceGain();
            playerExperience += expAmount;
            showExperienceGainIndicator(expAmount.toFixed(2));
            checkLevelUp();
        }

        function showPetExperienceGainIndicator(amount) {
            const indicator = document.createElement('div');
            indicator.textContent = `+${amount}`;
            indicator.className = 'exp-indicator';
            meditationContainerEl.appendChild(indicator);
            
            indicator.style.left = '85%'; 
            indicator.style.top = '65%';
            indicator.style.transform = 'translateX(-50%)';
            indicator.style.fontSize = '18px';

            setTimeout(() => indicator.remove(), 900);
        }

        function handlePetClick() {
            if (isAwaitingTribulation) return;

            playerExperience += 1;
            showPetExperienceGainIndicator(1);
            checkLevelUp(); 

            if (petCryTimeout) {
                clearTimeout(petCryTimeout);
            }
            
            petImgEl.src = PET_CRY_IMAGE;

            petCryTimeout = setTimeout(() => {
                petImgEl.src = PET_NORMAL_IMAGE;
            }, 300);
        }
        
        function updateUI() {
            playerAtkEl.textContent = playerStats.atk;
            playerDefEl.textContent = playerStats.def;
            playerSpdEl.textContent = playerStats.spd;
            playerHpTextEl.textContent = `${playerStats.hp} / ${playerStats.maxHp}`;
            playerHealthBarEl.style.width = `${(playerStats.hp / playerStats.maxHp) * 100}%`;
            playerActionBarEl.style.width = `${(playerStats.actionProgress / ACTION_THRESHOLD) * 100}%`;
            if (monsterStats.name) {
                monsterNameEl.textContent = `${monsterStats.name} Lv.${monsterLevel}`;
                monsterAtkEl.textContent = monsterStats.atk;
                monsterDefEl.textContent = monsterStats.def;
                monsterSpdEl.textContent = monsterStats.spd;
                monsterHpTextEl.textContent = `${monsterStats.hp} / ${monsterStats.maxHp}`;
                monsterHealthBarEl.style.width = `${(monsterStats.hp / monsterStats.maxHp) * 100}%`;
                monsterActionBarEl.style.width = `${(monsterStats.actionProgress / ACTION_THRESHOLD) * 100}%`;
            }
        }
        function showExperienceGainIndicator(amount) {
            const indicator = document.createElement('div');
            indicator.textContent = `+${amount}`;
            indicator.className = 'exp-indicator';
            meditationContainerEl.appendChild(indicator);
            const xOffset = (Math.random() - 0.5) * 40;
            indicator.style.left = `calc(50% + ${xOffset}px)`;
            indicator.style.top = '20%';
            indicator.style.transform = 'translateX(-50%)';
            setTimeout(() => indicator.remove(), 900);
        }
        function logMessage(message, color = '#e0e0e0') {
            if (combatLog.children.length > 100) { combatLog.removeChild(combatLog.lastChild); }
            const p = document.createElement('p');
            p.textContent = message;
            p.style.color = color;
            combatLog.prepend(p);
        }
        function showDamageIndicator(targetCard, damage) {
            const indicator = document.createElement('div');
            indicator.textContent = `-${damage}`;
            indicator.className = 'damage-indicator';
            combatScreenEl.appendChild(indicator);
            const xOffset = (Math.random() - 0.5) * 40;
            indicator.style.left = `${targetCard.offsetLeft + targetCard.offsetWidth / 2 - indicator.offsetWidth / 2 + xOffset}px`;
            indicator.style.top = `${targetCard.offsetTop}px`;
            setTimeout(() => indicator.remove(), 900);
        }
        function playAttackAnimation(targetCard, type) {
            const effect = document.createElement('div');
            effect.className = type === 'slash' ? 'slash-effect' : 'impact-effect';
            combatScreenEl.appendChild(effect);
            effect.style.left = `${targetCard.offsetLeft + targetCard.offsetWidth / 2 - effect.offsetWidth / 2}px`;
            effect.style.top = `${targetCard.offsetTop + targetCard.offsetHeight / 2 - effect.offsetHeight / 2}px`;
            setTimeout(() => effect.remove(), 350);
        }
        function spawnNextMonster() {
            monsterLevel++;
            logMessage(`遭遇新的敵人！`, '#FFD700');
            playerStats.hp = playerStats.maxHp;
            const monsterIndex = (monsterLevel - 1) % MONSTERS_DATABASE.length;
            const monsterData = MONSTERS_DATABASE[monsterIndex];
            monsterStats = { ...monsterData, hp: monsterData.maxHp, actionProgress: 0, };
            monsterSelectEl.value = monsterIndex;
        }
        function gameLoop() {
            if (!isGameRunning) return;
            const fasterSpd = Math.max(playerStats.spd, monsterStats.spd);
            if (fasterSpd <= 0) return;
            const desiredAttackTimeMs = 1000;
            const ticksToAttackForFaster = desiredAttackTimeMs / TICK_RATE; 
            const baseProgressGain = ACTION_THRESHOLD / ticksToAttackForFaster; 
            const playerProgressGain = baseProgressGain * (playerStats.spd / fasterSpd);
            const monsterProgressGain = baseProgressGain * (monsterStats.spd / fasterSpd);
            playerStats.actionProgress += playerProgressGain;
            monsterStats.actionProgress += monsterProgressGain;
            if (playerStats.actionProgress >= ACTION_THRESHOLD) {
                playerStats.actionProgress -= ACTION_THRESHOLD;
                let damage = Math.max(1, playerStats.atk - monsterStats.def);
                monsterStats.hp = Math.max(0, monsterStats.hp - damage);
                logMessage(`你對 ${monsterStats.name} 造成了 ${damage} 點傷害。`, '#87CEFA');
                showDamageIndicator(monsterCard, damage);
                playAttackAnimation(monsterCard, 'slash');
                monsterCard.classList.add('attacking');
                combatScreenEl.classList.add('screen-shake');
                setTimeout(() => {
                    monsterCard.classList.remove('attacking');
                    combatScreenEl.classList.remove('screen-shake');
                }, 300);
                if (monsterStats.hp <= 0) {
                    logMessage(`你擊敗了 ${monsterStats.name}！`, '#90EE90');
                    spawnNextMonster();
                }
            }
            if (monsterStats.actionProgress >= ACTION_THRESHOLD) {
                 if (monsterStats.hp > 0) {
                    monsterStats.actionProgress -= ACTION_THRESHOLD;
                    let damage = Math.max(1, playerStats.atk - playerStats.def);
                    playerStats.hp = Math.max(0, playerStats.hp - damage);
                    logMessage(`${monsterStats.name} 對你造成了 ${damage} 點傷害。`, '#F08080');
                    showDamageIndicator(playerCard, damage);
                    playAttackAnimation(playerCard, 'impact');
                    playerCard.classList.add('attacking');
                    combatScreenEl.classList.add('screen-shake');
                    setTimeout(() => {
                        playerCard.classList.remove('attacking');
                        combatScreenEl.classList.remove('screen-shake');
                    }, 300);
                    if (playerStats.hp <= 0) {
                        logMessage('你被擊敗了... 遊戲結束。', '#DC143C');
                        isGameRunning = false;
                        clearInterval(gameInterval);
                        gameInterval = null;
                        startPauseButton.style.display = 'none';
                        restartButton.style.display = 'block';
                    }
                } else {
                    monsterStats.actionProgress = 0;
                }
            }
            updateUI();
        }
        function toggleCombat() {
            isGameRunning = !isGameRunning;
            if (isGameRunning) {
                startPauseButton.textContent = '暫停戰鬥';
                if (!gameInterval) { gameInterval = setInterval(gameLoop, TICK_RATE); }
            } else {
                startPauseButton.textContent = '繼續戰鬥';
            }
        }
        
        function resetGame() {
            playerExperience = 0;
            cultivationLevelIndex = 0;
            isAwaitingTribulation = false;
            startSpecificMonsterFight(0);
            updateCultivationUI();
            updateRevolvingOrbs();
        }
        
        function startSpecificMonsterFight(monsterIndex) {
            isGameRunning = false;
            if (gameInterval) clearInterval(gameInterval);
            gameInterval = null;
            monsterLevel = monsterIndex + 1;
            playerStats = { ...initialPlayerStats, actionProgress: 0 };
            const selectedMonsterData = MONSTERS_DATABASE[monsterIndex];
            monsterStats = { ...selectedMonsterData, hp: selectedMonsterData.maxHp, actionProgress: 0 };
            combatLog.innerHTML = "";
            logMessage(`測試戰鬥開始！對手: ${monsterStats.name}`);
            startPauseButton.textContent = '開始戰鬥';
            startPauseButton.style.display = 'block';
            restartButton.style.display = 'none';
            monsterSelectEl.value = monsterIndex;
            updateUI();
        }

        // --- 4. 設定事件監聽 ---
        startPauseButton.addEventListener('click', toggleCombat);
        restartButton.addEventListener('click', resetGame);
        breakthroughButton.addEventListener('click', attemptBreakthrough);
        monsterSelectEl.addEventListener('change', (event) => {
            const selectedIndex = parseInt(event.target.value, 10);
            startSpecificMonsterFight(selectedIndex);
        });
        petImgEl.addEventListener('click', handlePetClick);
        editPetNameEl.addEventListener('click', () => {
            showCustomAlert('想改名? 求我啊~~');
        });
        customAlertClose.addEventListener('click', hideCustomAlert);
        customAlertOverlay.addEventListener('click', (event) => {
            if (event.target === customAlertOverlay) {
                hideCustomAlert();
            }
        });

        // --- 5. 遊戲初始化 ---
        function populateMonsterSelector() {
            MONSTERS_DATABASE.forEach((monster, index) => {
                const option = document.createElement('option');
                option.value = index;
                option.textContent = monster.name;
                monsterSelectEl.appendChild(option);
            });
        }

        function initGame() {
            populateMonsterSelector();
            logMessage("點擊按鈕開始自動戰鬥。");
            setInterval(gainExperience, 1000);
            fetchWeather();
            setInterval(fetchWeather, 900000);
            resetGame(); 
        }

        initGame();
    </script>
</body>
</html>

